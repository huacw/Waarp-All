<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractTask.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">Waarp Administrator</a> &gt; <a href="../index.html" class="el_bundle">WaarpR66</a> &gt; <a href="index.source.html" class="el_package">org.waarp.openr66.context.task</a> &gt; <span class="el_source">AbstractTask.java</span></div><h1>AbstractTask.java</h1><pre class="source lang-java linenums">/*
 * This file is part of Waarp Project (named also Waarp or GG).
 *
 *  Copyright (c) 2019, Waarp SAS, and individual contributors by the @author
 *  tags. See the COPYRIGHT.txt in the distribution for a full listing of
 * individual contributors.
 *
 *  All Waarp Project is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or (at your
 * option) any later version.
 *
 * Waarp is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along with
 * Waarp . If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */
package org.waarp.openr66.context.task;

import org.waarp.common.command.exception.CommandAbstractException;
import org.waarp.common.logging.WaarpLogger;
import org.waarp.common.logging.WaarpLoggerFactory;
import org.waarp.common.utility.WaarpStringUtils;
import org.waarp.openr66.context.ErrorCode;
import org.waarp.openr66.context.R66Session;
import org.waarp.openr66.context.filesystem.R66Dir;
import org.waarp.openr66.context.filesystem.R66File;
import org.waarp.openr66.database.data.DbTaskRunner;
import org.waarp.openr66.protocol.configuration.Configuration;
import org.waarp.openr66.protocol.exception.OpenR66ProtocolNoSslException;
import org.waarp.openr66.protocol.utils.R66Future;

import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.regex.Pattern;

/**
 * Abstract implementation of task
 */
public abstract class AbstractTask implements Runnable {
  /**
   * Internal Logger
   */
<span class="fc" id="L48">  private static final WaarpLogger logger =</span>
<span class="fc" id="L49">      WaarpLoggerFactory.getLogger(AbstractTask.class);</span>
<span class="fc" id="L50">  protected static final Pattern BLANK = Pattern.compile(&quot; &quot;);</span>
  /**
   * Current full path of current FILENAME
   */
  public static final String TRUEFULLPATH = &quot;#TRUEFULLPATH#&quot;;

  /**
   * Current FILENAME (basename) (change in retrieval part)
   */
  public static final String TRUEFILENAME = &quot;#TRUEFILENAME#&quot;;
  /**
   * Current full path of Original FILENAME (as transmitted) (before changing
   * in
   * retrieval part)
   */
  public static final String ORIGINALFULLPATH = &quot;#ORIGINALFULLPATH#&quot;;

  /**
   * Original FILENAME (basename) (before changing in retrieval part)
   */
  public static final String ORIGINALFILENAME = &quot;#ORIGINALFILENAME#&quot;;

  /**
   * Size of the current FILE
   */
  public static final String FILESIZE = &quot;#FILESIZE#&quot;;

  /**
   * Current full path of current RULE
   */
  public static final String RULE = &quot;#RULE#&quot;;

  /**
   * Date in yyyyMMdd format
   */
  public static final String DATE = &quot;#DATE#&quot;;

  /**
   * Hour in HHmmss format
   */
  public static final String HOUR = &quot;#HOUR#&quot;;

  /**
   * Remote host id (if not the initiator of the call)
   */
  public static final String REMOTEHOST = &quot;#REMOTEHOST#&quot;;

  /**
   * Remote host address
   */
  public static final String REMOTEHOSTADDR = &quot;#REMOTEHOSTADDR#&quot;;

  /**
   * Local host id
   */
  public static final String LOCALHOST = &quot;#LOCALHOST#&quot;;

  /**
   * Local host address
   */
  public static final String LOCALHOSTADDR = &quot;#LOCALHOSTADDR#&quot;;

  /**
   * Transfer id
   */
  public static final String TRANSFERID = &quot;#TRANSFERID#&quot;;

  /**
   * Requester Host
   */
  public static final String REQUESTERHOST = &quot;#REQUESTERHOST#&quot;;

  /**
   * Requested Host
   */
  public static final String REQUESTEDHOST = &quot;#REQUESTEDHOST#&quot;;

  /**
   * Full Transfer id (TRANSFERID_REQUESTERHOST_REQUESTEDHOST)
   */
  public static final String FULLTRANSFERID = &quot;#FULLTRANSFERID#&quot;;

  /**
   * Current or final RANK of block
   */
  public static final String RANKTRANSFER = &quot;#RANKTRANSFER#&quot;;

  /**
   * Block size used
   */
  public static final String BLOCKSIZE = &quot;#BLOCKSIZE#&quot;;

  /**
   * IN Path used
   */
  public static final String INPATH = &quot;#INPATH#&quot;;

  /**
   * OUT Path used
   */
  public static final String OUTPATH = &quot;#OUTPATH#&quot;;

  /**
   * WORK Path used
   */
  public static final String WORKPATH = &quot;#WORKPATH#&quot;;

  /**
   * ARCH Path used
   */
  public static final String ARCHPATH = &quot;#ARCHPATH#&quot;;

  /**
   * HOME Path used
   */
  public static final String HOMEPATH = &quot;#HOMEPATH#&quot;;
  /**
   * Last Current Error Message
   */
  public static final String ERRORMSG = &quot;#ERRORMSG#&quot;;
  /**
   * Last Current Error Code
   */
  public static final String ERRORCODE = &quot;#ERRORCODE#&quot;;
  /**
   * Last Current Error Code in Full String
   */
  public static final String ERRORSTRCODE = &quot;#ERRORSTRCODE#&quot;;
  /**
   * If specified, no Wait for Task Validation (default is wait)
   */
  public static final String NOWAIT = &quot;#NOWAIT#&quot;;
  /**
   * If specified, use the LocalExec Daemon specified in the global
   * configuration (default no usage of
   * LocalExec)
   */
  public static final String LOCALEXEC = &quot;#LOCALEXEC#&quot;;

  /**
   * Type of operation
   */
  final TaskType type;

  /**
   * Argument from Rule
   */
  final String argRule;

  /**
   * Delay from Rule (if applicable)
   */
  final int delay;

  /**
   * Argument from Transfer
   */
  final String argTransfer;

  /**
   * Current session
   */
  final R66Session session;

  /**
   * R66Future of completion
   */
  final R66Future futureCompletion;
  /**
   * Do we wait for a validation of the task ? Default = True
   */
<span class="fc" id="L221">  boolean waitForValidation = true;</span>
  /**
   * Do we need to use LocalExec for an Exec Task ? Default = False
   */
  boolean useLocalExec;

  /**
   * Constructor
   *
   * @param type
   * @param delay
   * @param argRule
   * @param argTransfer
   * @param session
   */
  AbstractTask(TaskType type, int delay, String argRule, String argTransfer,
<span class="fc" id="L237">               R66Session session) {</span>
<span class="fc" id="L238">    this.type = type;</span>
<span class="fc" id="L239">    this.delay = delay;</span>
<span class="fc" id="L240">    this.argRule = argRule;</span>
<span class="fc" id="L241">    this.argTransfer = argTransfer;</span>
<span class="fc" id="L242">    this.session = session;</span>
<span class="fc" id="L243">    futureCompletion = new R66Future(true);</span>
<span class="fc" id="L244">  }</span>

  /**
   * @return the TaskType of this AbstractTask
   */
  public TaskType getType() {
<span class="fc" id="L250">    return type;</span>
  }

  /**
   * This is the only interface to execute an operator.
   */
  @Override
  public abstract void run();

  /**
   * @return True if the operation is in success status
   */
  public boolean isSuccess() {
<span class="fc" id="L263">    futureCompletion.awaitOrInterruptible();</span>
<span class="fc" id="L264">    return futureCompletion.isSuccess();</span>
  }

  /**
   * @return the R66Future of completion
   */
  public R66Future getFutureCompletion() {
<span class="fc" id="L271">    return futureCompletion;</span>
  }

  /**
   * @param arg as the Format string where FIXED items will be
   *     replaced by
   *     context values and next using
   *     argFormat as format second argument; this arg comes from the
   *     rule
   *     itself
   * @param argFormat as format second argument; this argFormat comes
   *     from
   *     the transfer Information itself
   *
   * @return The string with replaced values from context and second argument
   */
  protected String getReplacedValue(String arg, Object[] argFormat) {
<span class="fc" id="L288">    final StringBuilder builder = new StringBuilder(arg);</span>
    // check NOWAIT and LOCALEXEC
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">    if (arg.contains(NOWAIT)) {</span>
<span class="nc" id="L291">      waitForValidation = false;</span>
<span class="nc" id="L292">      WaarpStringUtils.replaceAll(builder, NOWAIT, &quot;&quot;);</span>
    }
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">    if (arg.contains(LOCALEXEC)) {</span>
<span class="nc" id="L295">      useLocalExec = true;</span>
<span class="nc" id="L296">      WaarpStringUtils.replaceAll(builder, LOCALEXEC, &quot;&quot;);</span>
    }
<span class="fc" id="L298">    File trueFile = null;</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">    if (session.getFile() != null) {</span>
<span class="fc" id="L300">      trueFile = session.getFile().getTrueFile();</span>
    }
<span class="fc bfc" id="L302" title="All 2 branches covered.">    if (trueFile != null) {</span>
<span class="fc" id="L303">      WaarpStringUtils</span>
<span class="fc" id="L304">          .replaceAll(builder, TRUEFULLPATH, trueFile.getAbsolutePath());</span>
<span class="fc" id="L305">      WaarpStringUtils.replaceAll(builder, TRUEFILENAME, R66Dir</span>
<span class="fc" id="L306">          .getFinalUniqueFilename(session.getFile()));</span>
<span class="fc" id="L307">      WaarpStringUtils</span>
<span class="fc" id="L308">          .replaceAll(builder, FILESIZE, Long.toString(trueFile.length()));</span>
    } else {
<span class="fc" id="L310">      WaarpStringUtils.replaceAll(builder, TRUEFULLPATH, &quot;nofile&quot;);</span>
<span class="fc" id="L311">      WaarpStringUtils.replaceAll(builder, TRUEFILENAME, &quot;nofile&quot;);</span>
<span class="fc" id="L312">      WaarpStringUtils.replaceAll(builder, FILESIZE, &quot;0&quot;);</span>
    }
<span class="fc" id="L314">    final DbTaskRunner runner = session.getRunner();</span>
<span class="fc bfc" id="L315" title="All 2 branches covered.">    if (runner != null) {</span>
<span class="fc" id="L316">      WaarpStringUtils</span>
<span class="fc" id="L317">          .replaceAll(builder, ORIGINALFULLPATH, runner.getOriginalFilename());</span>
<span class="fc" id="L318">      WaarpStringUtils.replaceAll(builder, ORIGINALFILENAME, R66File</span>
<span class="fc" id="L319">          .getBasename(runner.getOriginalFilename()));</span>
<span class="fc" id="L320">      WaarpStringUtils.replaceAll(builder, RULE, runner.getRuleId());</span>
    }
<span class="fc" id="L322">    DateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);</span>
<span class="fc" id="L323">    final Date date = new Date();</span>
<span class="fc" id="L324">    WaarpStringUtils.replaceAll(builder, DATE, dateFormat.format(date));</span>
<span class="fc" id="L325">    dateFormat = new SimpleDateFormat(&quot;HHmmss&quot;);</span>
<span class="fc" id="L326">    WaarpStringUtils.replaceAll(builder, HOUR, dateFormat.format(date));</span>
<span class="pc bpc" id="L327" title="1 of 2 branches missed.">    if (session.getAuth() != null) {</span>
<span class="fc" id="L328">      WaarpStringUtils</span>
<span class="fc" id="L329">          .replaceAll(builder, REMOTEHOST, session.getAuth().getUser());</span>
      try {
<span class="fc" id="L331">        WaarpStringUtils.replaceAll(builder, LOCALHOST,</span>
                                    Configuration.configuration
<span class="fc" id="L333">                                        .getHostId(session.getAuth().isSsl()));</span>
<span class="nc" id="L334">      } catch (final OpenR66ProtocolNoSslException e) {</span>
        // replace by standard name
<span class="nc" id="L336">        WaarpStringUtils.replaceAll(builder, LOCALHOST,</span>
<span class="nc" id="L337">                                    Configuration.configuration.getHostId());</span>
<span class="fc" id="L338">      }</span>
    }
<span class="fc bfc" id="L340" title="All 2 branches covered.">    if (session.getRemoteAddress() != null) {</span>
<span class="fc" id="L341">      WaarpStringUtils.replaceAll(builder, REMOTEHOSTADDR,</span>
<span class="fc" id="L342">                                  session.getRemoteAddress().toString());</span>
<span class="fc" id="L343">      WaarpStringUtils.replaceAll(builder, LOCALHOSTADDR,</span>
<span class="fc" id="L344">                                  session.getLocalAddress().toString());</span>
    } else {
<span class="fc" id="L346">      WaarpStringUtils.replaceAll(builder, REMOTEHOSTADDR, &quot;unknown&quot;);</span>
<span class="fc" id="L347">      WaarpStringUtils.replaceAll(builder, LOCALHOSTADDR, &quot;unknown&quot;);</span>
    }
<span class="fc bfc" id="L349" title="All 2 branches covered.">    if (runner != null) {</span>
<span class="fc" id="L350">      WaarpStringUtils.replaceAll(builder, TRANSFERID,</span>
<span class="fc" id="L351">                                  Long.toString(runner.getSpecialId()));</span>
<span class="fc" id="L352">      final String requester = runner.getRequester();</span>
<span class="fc" id="L353">      WaarpStringUtils.replaceAll(builder, REQUESTERHOST, requester);</span>
<span class="fc" id="L354">      final String requested = runner.getRequested();</span>
<span class="fc" id="L355">      WaarpStringUtils.replaceAll(builder, REQUESTEDHOST, requested);</span>
<span class="fc" id="L356">      WaarpStringUtils.replaceAll(builder, FULLTRANSFERID,</span>
<span class="fc" id="L357">                                  runner.getSpecialId() + &quot;_&quot; + requester +</span>
                                  '_' + requested);
<span class="fc" id="L359">      WaarpStringUtils.replaceAll(builder, RANKTRANSFER,</span>
<span class="fc" id="L360">                                  Integer.toString(runner.getRank()));</span>
    }
<span class="fc" id="L362">    WaarpStringUtils.replaceAll(builder, BLOCKSIZE,</span>
<span class="fc" id="L363">                                Integer.toString(session.getBlockSize()));</span>
<span class="fc" id="L364">    R66Dir dir = new R66Dir(session);</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">    if (runner != null) {</span>
<span class="fc bfc" id="L366" title="All 4 branches covered.">      if (runner.isRecvThrough() || runner.isSendThrough()) {</span>
        try {
<span class="fc" id="L368">          dir.changeDirectoryNotChecked(runner.getRule().getRecvPath());</span>
<span class="fc" id="L369">          WaarpStringUtils.replaceAll(builder, INPATH, dir.getFullPath());</span>
<span class="nc" id="L370">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L372">        }</span>
<span class="fc" id="L373">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L375">          dir.changeDirectoryNotChecked(runner.getRule().getSendPath());</span>
<span class="fc" id="L376">          WaarpStringUtils.replaceAll(builder, OUTPATH, dir.getFullPath());</span>
<span class="nc" id="L377">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L379">        }</span>
<span class="fc" id="L380">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L382">          dir.changeDirectoryNotChecked(runner.getRule().getWorkPath());</span>
<span class="fc" id="L383">          WaarpStringUtils.replaceAll(builder, WORKPATH, dir.getFullPath());</span>
<span class="nc" id="L384">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L386">        }</span>
<span class="fc" id="L387">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L389">          dir.changeDirectoryNotChecked(runner.getRule().getArchivePath());</span>
<span class="fc" id="L390">          WaarpStringUtils.replaceAll(builder, ARCHPATH, dir.getFullPath());</span>
<span class="nc" id="L391">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="pc" id="L393">        }</span>
      } else {
        try {
<span class="fc" id="L396">          dir.changeDirectory(runner.getRule().getRecvPath());</span>
<span class="fc" id="L397">          WaarpStringUtils.replaceAll(builder, INPATH, dir.getFullPath());</span>
<span class="nc" id="L398">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L400">        }</span>
<span class="fc" id="L401">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L403">          dir.changeDirectory(runner.getRule().getSendPath());</span>
<span class="fc" id="L404">          WaarpStringUtils.replaceAll(builder, OUTPATH, dir.getFullPath());</span>
<span class="nc" id="L405">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L407">        }</span>
<span class="fc" id="L408">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L410">          dir.changeDirectory(runner.getRule().getWorkPath());</span>
<span class="fc" id="L411">          WaarpStringUtils.replaceAll(builder, WORKPATH, dir.getFullPath());</span>
<span class="nc" id="L412">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="fc" id="L414">        }</span>
<span class="fc" id="L415">        dir = new R66Dir(session);</span>
        try {
<span class="fc" id="L417">          dir.changeDirectory(runner.getRule().getArchivePath());</span>
<span class="fc" id="L418">          WaarpStringUtils.replaceAll(builder, ARCHPATH, dir.getFullPath());</span>
<span class="nc" id="L419">        } catch (final CommandAbstractException ignored) {</span>
          // nothing
<span class="pc" id="L421">        }</span>
      }
    } else {
      try {
<span class="fc" id="L425">        dir.changeDirectory(Configuration.configuration.getInPath());</span>
<span class="fc" id="L426">        WaarpStringUtils.replaceAll(builder, INPATH, dir.getFullPath());</span>
<span class="nc" id="L427">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L429">      }</span>
<span class="fc" id="L430">      dir = new R66Dir(session);</span>
      try {
<span class="fc" id="L432">        dir.changeDirectory(Configuration.configuration.getOutPath());</span>
<span class="fc" id="L433">        WaarpStringUtils.replaceAll(builder, OUTPATH, dir.getFullPath());</span>
<span class="nc" id="L434">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L436">      }</span>
<span class="fc" id="L437">      dir = new R66Dir(session);</span>
      try {
<span class="fc" id="L439">        dir.changeDirectory(Configuration.configuration.getWorkingPath());</span>
<span class="fc" id="L440">        WaarpStringUtils.replaceAll(builder, WORKPATH, dir.getFullPath());</span>
<span class="nc" id="L441">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L443">      }</span>
<span class="fc" id="L444">      dir = new R66Dir(session);</span>
      try {
<span class="fc" id="L446">        dir.changeDirectory(Configuration.configuration.getArchivePath());</span>
<span class="fc" id="L447">        WaarpStringUtils.replaceAll(builder, ARCHPATH, dir.getFullPath());</span>
<span class="nc" id="L448">      } catch (final CommandAbstractException ignored) {</span>
        // nothing
<span class="fc" id="L450">      }</span>
    }
<span class="fc" id="L452">    WaarpStringUtils.replaceAll(builder, HOMEPATH,</span>
<span class="fc" id="L453">                                Configuration.configuration.getBaseDirectory());</span>
<span class="fc bfc" id="L454" title="All 2 branches covered.">    if (session.getLocalChannelReference() == null) {</span>
<span class="fc" id="L455">      WaarpStringUtils.replaceAll(builder, ERRORMSG, &quot;NoError&quot;);</span>
<span class="fc" id="L456">      WaarpStringUtils.replaceAll(builder, ERRORCODE, &quot;-&quot;);</span>
<span class="fc" id="L457">      WaarpStringUtils</span>
<span class="fc" id="L458">          .replaceAll(builder, ERRORSTRCODE, ErrorCode.Unknown.name());</span>
    } else {
      try {
<span class="fc" id="L461">        WaarpStringUtils.replaceAll(builder, ERRORMSG,</span>
<span class="fc" id="L462">                                    session.getLocalChannelReference()</span>
<span class="fc" id="L463">                                           .getErrorMessage());</span>
<span class="nc" id="L464">      } catch (final NullPointerException e) {</span>
<span class="nc" id="L465">        WaarpStringUtils.replaceAll(builder, ERRORMSG, &quot;NoError&quot;);</span>
<span class="fc" id="L466">      }</span>
      try {
<span class="fc" id="L468">        WaarpStringUtils.replaceAll(builder, ERRORCODE,</span>
<span class="fc" id="L469">                                    session.getLocalChannelReference()</span>
<span class="fc" id="L470">                                           .getCurrentCode().getCode());</span>
<span class="nc" id="L471">      } catch (final NullPointerException e) {</span>
<span class="nc" id="L472">        WaarpStringUtils.replaceAll(builder, ERRORCODE, &quot;-&quot;);</span>
<span class="fc" id="L473">      }</span>
      try {
<span class="fc" id="L475">        WaarpStringUtils.replaceAll(builder, ERRORSTRCODE,</span>
<span class="fc" id="L476">                                    session.getLocalChannelReference()</span>
<span class="fc" id="L477">                                           .getCurrentCode().name());</span>
<span class="nc" id="L478">      } catch (final NullPointerException e) {</span>
<span class="nc" id="L479">        WaarpStringUtils</span>
<span class="nc" id="L480">            .replaceAll(builder, ERRORSTRCODE, ErrorCode.Unknown.name());</span>
<span class="fc" id="L481">      }</span>
    }
    // finalname
<span class="pc bpc" id="L484" title="2 of 4 branches missed.">    if (argFormat != null &amp;&amp; argFormat.length &gt; 0) {</span>
      try {
<span class="fc" id="L486">        return String.format(builder.toString(), argFormat);</span>
<span class="nc" id="L487">      } catch (final Exception e) {</span>
        // ignored error since bad argument in static rule info
<span class="nc" id="L489">        logger.error(&quot;Bad format in Rule: {&quot; + builder + &quot;} &quot; + e.getMessage());</span>
      }
    }
<span class="nc" id="L492">    return builder.toString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>